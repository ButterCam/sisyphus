package com.bybutter.sisyphus.middleware.grpc

import com.bybutter.sisyphus.rpc.GrpcServerConstants
import com.bybutter.sisyphus.rpc.RpcService
import io.grpc.CallOptions
import io.grpc.Channel
import io.grpc.ClientInterceptor
import io.grpc.ManagedChannelBuilder
import io.grpc.stub.AbstractStub
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory
import org.springframework.beans.factory.getBeansOfType
import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.support.BeanDefinitionRegistry
import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor
import org.springframework.context.EnvironmentAware
import org.springframework.core.annotation.AnnotationUtils
import org.springframework.core.env.Environment
import org.springframework.stereotype.Component
import kotlin.reflect.full.companionObject

@Component
class ClientRegistrar : BeanDefinitionRegistryPostProcessor, EnvironmentAware {
    companion object {
        private val logger = LoggerFactory.getLogger(ClientRegistrar::class.java)
    }

    private lateinit var environment: Environment

    override fun setEnvironment(environment: Environment) {
        this.environment = environment
    }

    override fun postProcessBeanFactory(beanFactory: ConfigurableListableBeanFactory) {
        val registry = beanFactory as BeanDefinitionRegistry
        val localPort = environment.getProperty(GrpcServerConstants.GRPC_PORT_PROPERTY, Int::class.java, GrpcServerConstants.DEFAULT_GRPC_PORT)
        val localChannel = ManagedChannelBuilder.forTarget("localhost:$localPort").usePlaintext().userAgent("Generated by Sisyphus").build()

        for (serviceName in beanFactory.getBeanNamesForAnnotation(RpcServiceImpl::class.java)) {
            val serviceBeanDefinition = registry.getBeanDefinition(serviceName)

            val serviceClass = Class.forName(serviceBeanDefinition.beanClassName)
            val rpcService = AnnotationUtils.findAnnotation(serviceClass, RpcService::class.java) ?: continue
            val service = rpcService.client.java.declaringClass
            val stub = service.kotlin.companionObject?.java?.classes?.firstOrNull {
                it.name == "Stub"
            } ?: throw IllegalStateException("Grpc service must have stub class in companion.")

            val clientBeanDefinition = BeanDefinitionBuilder.genericBeanDefinition(rpcService.client.java as Class<Any>) {
                processStub(createGrpcClient(stub, localChannel), beanFactory)
            }

            registry.registerBeanDefinition(rpcService.value, clientBeanDefinition.beanDefinition)
            logger.info("Register '${rpcService.value}Clinet' via local service implement '$serviceName'")
        }

        val properties = beanFactory.getBeansOfType<GrpcChannelProperty>()
        if (properties.isEmpty()) return

        for (property in properties.values) {
            val channel = createGrpcChannel(property)
            beanFactory.registerSingleton(property.name, channel)

            for (service in property.services) {
                val rpcService = service.getAnnotation(RpcService::class.java)
                    ?: throw IllegalStateException("Grpc service must be annotated with 'RpcService'.")
                val client = service.declaredClasses.firstOrNull { it.name == "Client" }
                    ?: throw IllegalStateException("Grpc service must have nested class named 'Client'.")
                val stub = service.kotlin.companionObject?.java?.classes?.firstOrNull {
                    it.name == "Stub"
                } ?: throw IllegalStateException("Grpc service must have stub class in companion.")

                if (registry.containsBeanDefinition(rpcService.value)) {
                    continue
                }

                val clientBeanDefinition = BeanDefinitionBuilder.genericBeanDefinition(client as Class<Any>) {
                    processStub(createGrpcClient(stub, channel, property), beanFactory)
                }

                registry.registerBeanDefinition(rpcService.value, clientBeanDefinition.beanDefinition)
                logger.info("Register '${rpcService.value}($service)' via remote service '${property.target}'")
            }
        }
    }

    override fun postProcessBeanDefinitionRegistry(registry: BeanDefinitionRegistry) {
    }

    private fun processStub(stub: AbstractStub<*>, beanFactory: ConfigurableListableBeanFactory): AbstractStub<*> {
        var result = stub

        val builderInterceptors = beanFactory.getBeansOfType(ClientBuilderInterceptor::class.java)
        for ((_, builderInterceptor) in builderInterceptors) {
            result = builderInterceptor.intercept(result)
        }

        val interceptors = beanFactory.getBeansOfType(ClientInterceptor::class.java)
        return result.withInterceptors(*interceptors.values.toTypedArray())
    }

    private fun createGrpcChannel(property: GrpcChannelProperty): Channel {
        return ManagedChannelBuilder.forTarget(property.target).usePlaintext().userAgent("Generated by Sisyphus").build()
    }

    private fun createGrpcClient(target: Class<*>, channel: Channel, property: GrpcChannelProperty): AbstractStub<*> {
        return target.getDeclaredConstructor(Channel::class.java, CallOptions::class.java)
            .newInstance(channel, property.options) as AbstractStub<*>
    }

    private fun createGrpcClient(target: Class<*>, channel: Channel): AbstractStub<*> {
        return target.getDeclaredConstructor(Channel::class.java, CallOptions::class.java)
            .newInstance(channel, CallOptions.DEFAULT) as AbstractStub<*>
    }
}
