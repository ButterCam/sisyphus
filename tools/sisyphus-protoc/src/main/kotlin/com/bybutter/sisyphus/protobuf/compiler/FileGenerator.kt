package com.bybutter.sisyphus.protobuf.compiler

import com.bybutter.sisyphus.api.resourceDefinition
import com.bybutter.sisyphus.io.replaceExtensionName
import com.bybutter.sisyphus.protobuf.ProtoFileMeta
import com.bybutter.sisyphus.protobuf.ProtoTypes
import com.bybutter.sisyphus.protobuf.primitives.FileDescriptorProto
import com.bybutter.sisyphus.protobuf.primitives.FileOptions
import com.bybutter.sisyphus.string.toPascalCase
import com.google.protobuf.DescriptorProtos
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.buildCodeBlock
import java.nio.file.Paths

class FileGenerator(override val parent: ProtobufGenerateContext, val descriptor: DescriptorProtos.FileDescriptorProto) : ProtobufElement() {
    override val protoName: String = descriptor.`package`.takeIf { it.isNotEmpty() } ?: ""
    override val kotlinName: String = parent.packageMapping[protoName]
            ?: descriptor.options?.javaPackage?.takeIf { it.isNotEmpty() } ?: protoName

    val protoFileNameWithoutExtension = Paths.get(descriptor.name).toFile().nameWithoutExtension
    val kotlinFileNameWithoutExtension = protoFileNameWithoutExtension.toPascalCase()
    val protoFilePath = descriptor.name
    val kotlinFilePath = "$kotlinName.$kotlinFileNameWithoutExtension".replace('.', '/') + ".kt"
    val isProto2 = descriptor.syntax.isBlank() || descriptor.syntax == "proto2"
    val isProto3 = descriptor.syntax == "proto3"
    val fileMeta = "${kotlinFileNameWithoutExtension}FileMeta"
    val internalKotlinName = "proto.internal.$kotlinName"
    val fileMetaTypeName = ClassName(internalKotlinName, fileMeta)
    val fileDescPath = protoFilePath.replaceExtensionName("proto", "pb")

    override val documentation: String = """Generated by the protocol buffer dto plugin.  DO NOT EDIT!
                |file: $kotlinFilePath
                |source: $protoFilePath
                |syntax: ${if (descriptor.syntax.isBlank()) "proto2" else descriptor.syntax}""".trimMargin()

    override fun init() {
        super.init()
        for (type in descriptor.messageTypeList) {
            addElement(MessageGenerator(this, type))
        }

        for (type in descriptor.enumTypeList) {
            addElement(EnumGenerator(this, type))
        }

        for (service in descriptor.serviceList) {
            addElement(ServiceGenerator(this, service))
        }

        val resourceDescriptorList = FileOptions.parse(descriptor.options.toByteArray()).resourceDefinition
        for (resource in resourceDescriptorList) {
            addElements(ResourceNameParentGenerator(this, resource))
        }
    }

    override fun prepareGenerating() {
        for ((extendee, fields) in descriptor.extensionList.groupBy { it.extendee }) {
            addElement(ExtensionsGenerator(this, getElementByProtoName(extendee) as MessageGenerator, fields))
        }
        super.prepareGenerating()
    }

    fun generate(): FileSpec {
        val builder = FileSpec.builder(kotlinName, kotlinFileNameWithoutExtension)
                .addComment(documentation)

        for (child in children) {
            when (child) {
                is ExtensionsGenerator -> {
                    child.applyToFile(builder)
                    builder.addType(child.generate())
                }
                is MessageGenerator -> {
                    builder.addType(child.generate())
                }
                is EnumGenerator -> {
                    builder.addType(child.generate())
                }
                is ServiceGenerator -> {
                    builder.addType(child.generate())
                }
                is ResourceNameParentGenerator -> {
                    builder.addType(child.generate())
                    for (typeSpec in child.generateImpl()) {
                        builder.addType(typeSpec)
                    }
                }
            }
        }

        return builder.build()
    }

    fun generateInternal(): FileSpec {
        return FileSpec.builder(internalKotlinName, kotlinFileNameWithoutExtension)
                .addType(generateFileMeta())
                .apply {
                    for (child in children) {
                        when (child) {
                            is MessageGenerator -> {
                                addType(child.generateMutable())
                                addType(child.generateImpl())
                                addType(child.generateSupport())
                            }
                            is ResourceNameParentGenerator -> {
                                addType(child.generateSupport())
                            }
                            is ServiceGenerator -> {
                                addType(child.generateSupport())
                            }
                        }
                    }
                }
                .build()
    }

    fun generateFileMeta(): TypeSpec {
        return TypeSpec.objectBuilder(fileMeta)
                .addSuperinterface(ProtoFileMeta::class)
                .addProperty(
                        PropertySpec.builder("name", String::class)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer("%S", protoFilePath)
                                .build()
                )
                .addProperty(
                        PropertySpec.builder("descriptor", FileDescriptorProto::class)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer("%T.parse(this.javaClass.classLoader.getResourceAsStream(%S))",
                                        FileDescriptorProto::class,
                                        "$fileDescPath")
                                .build()
                )
                .addInitializerBlock(
                        buildCodeBlock {
                            registerTypes(this, this@FileGenerator)
                        }
                )
                .build()
    }

    private fun registerTypes(builder: CodeBlock.Builder, element: ProtobufElement) {
        when (element) {
            is FileGenerator -> {
                builder.addStatement("%T.registerFileMeta(this)", ProtoTypes::class)
            }
            is ExtensionsGenerator -> {
                builder.addStatement("%T.registerExtension(%T)", element.messageGenerator.kotlinType, element.kotlinType)
            }
            is MessageGenerator -> {
                builder.addStatement("%T.registerProtoType(%S, %T::class)", ProtoTypes::class, element.fullProtoName, element.kotlinType)
            }
            is EnumGenerator -> {
                builder.addStatement("%T.registerProtoType(%S, %T::class)", ProtoTypes::class, element.fullProtoName, element.kotlinType)
            }
            is ServiceGenerator -> {
                builder.addStatement("%T.registerService(%S, %T::class)", ProtoTypes::class, element.fullProtoName, element.serviceType)
            }
            else -> {
            }
        }

        for (child in element.children) {
            registerTypes(builder, child)
        }
    }
}
